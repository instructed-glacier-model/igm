iceflow:
  iceflow: # temporarly mirroring the code but would recommend just cateogorizing the prameters that make sense (i.e. network params, retrain, paths, etc.)
    run_pretraining: False
    run_data_assimilation: False # help="Run the data assimilation scheme"
    type: "emulated" # help="Type of iceflow: it can emulated (default), solved, or in diagnostic mode to investigate the fidelity of the emulator towads the solver"
    pretrained_emulator: True # help="Do we take a pretrained emulator or start from scratch?"
    emulator: "" # help="Directory path of the deep-learning pretrained ice flow model, take from the library if empty string"
    init_slidingco: 0.0464 # help="Initial sliding coefficient slidingco"
    init_arrhenius: 78.0 # help="Initial arrhenius factor arrhenuis"
    enhancement_factor: 1.0 # help="Enhancement factor multiying the arrhenius factor"
    regu_glen: 1e-5 # help="Regularization parameter for Glen's flow law"
    regu_weertman: 1e-10 # help="Regularization parameter for Weertman's sliding law"
    exp_glen: 3.0 # help="Glen's flow law exponent"
    exp_weertman: 3.0 # help="Weertman temporary fix ...
    sliding_law:
      exponent:
        weertman: 3.0 # help="Weertman's law exponent
        budd: 3 # help="Budds's law exponent
        coulomb: 3 # help="coulombs's law exponent
      coefficient:
        weertman: 0.0464 # help="Weertman's law coefficient
        budd: 5e-9 # help="Budds's law coefficient
        coulomb: 0.25 # help="coulombs's law coefficient
    gamma_0: 2e-17
    gravity_cst: 9.81 # help="Gravitational constant"
    ice_density: 910.0 # help="Density of ice"
    new_friction_param: True # help="Sliding coeeficient (this describe slidingco differently with slidingco**-(1.0 / exp_weertman) instead of slidingco as before)"
    save_model: False # help="save the iceflow emaultor at the end of the simulation"
    Nz: 10 # help="Number of grid point for the vertical discretization"
    vert_spacing: 4.0 # help="Parameter controlling the discrtuzation density to get more point near the bed than near the the surface. 1.0 means equal vertical spacing."
    thr_ice_thk: 0.1 # help="Threshold Ice thickness for computing strain rate"
    solve_step_size: 1.0 # help="Step size for the optimizer using when solving Blatter-Pattyn in solver mode"
    solve_nbitmax: 100 # help="Maximum number of iteration for the optimizer using when solving Blatter-Pattyn in solver mode"
    solve_stop_if_no_decrease: True # help="This permits to stop the solver if the energy does not decrease"
    fieldin: ["thk", "usurf", "arrhenius", "slidingco", "dX"] # help="Input fields of the iceflow emulator"
    dim_arrhenius: 2 # help="Dimension of the arrhenius factor (horizontal 2D or 3D)"
    retrain_emulator_freq: 10 # help="Frequency at which the emulator is retrained, 0 means never, 1 means at each time step, 2 means every two time steps, etc."
    retrain_emulator_lr: 0.00002 # help="Learning rate for the retraining of the emulator"
    retrain_emulator_nbit_init: 1 # help="Number of iterations done at the first time step for the retraining of the emulator"
    retrain_emulator_nbit: 1 # help="Number of iterations done at each time step for the retraining of the emulator"
    retrain_emulator_framesizemax: 750 # help="Size of the patch used for retraining the emulator, this is usefull for large size arrays, otherwise the GPU memory can be overloaded"
    multiple_window_size: 0 # help="If a U-net, this force window size a multiple of 2**N"
    force_max_velbar: 0.0 # help="This permits to artifically upper-bound velocities, active if > 0"
    network: "cnn" # help="This is the type of network, it can be cnn or unet"
    activation: "LeakyReLU" # help="Activation function, it can be lrelu, relu, tanh, sigmoid, etc."
    nb_layers: 16 # help="Number of layers in the CNN"
    nb_blocks: 4 # help="Number of block layer in the U-net"
    nb_out_filter: 32 # help="Number of output filters in the CNN"
    conv_ker_size: 3 # help="Size of the convolution kernel"
    dropout_rate: 0 # help="Dropout rate in the CNN"
    weight_initialization: "glorot_uniform" # help="glorot_uniform, he_normal, lecun_normal"
    exclude_borders: 0 # help="This is a quick fix of the border issue, other the physics informed emaulator shows zero velocity at the border"
    cf_eswn: [] # help="This forces calving front at the border of the domain in the side given in the list"
    cf_cond: False # help="This forces calving front at the border of the domain in the side given in the list"
    regu: 0.0 # help="This regularizes the energy forcing ice flow to be smooth in the horizontal direction"
    min_sr: 1e-20 # help="Minimum strain rate"
    max_sr: 1e20 # help="Maximum strain rate"
    force_negative_gravitational_energy: False # help="Force energy gravitational term to be negative"
    optimizer_solver: 'Adam' # help="Tpe of Optimizer for the solver"
    optimizer_lbfgs: False # help="optimizer_lbfgs"
    optimizer_emulator: 'Adam' # help="Tpe of Optimizer for the emulator"
    save_cost_emulator: "" # 
    save_cost_solver: ""
    output_directory: ""
  optimize:
    vars_to_save: # help="List of variables to be recorded in the ncdef file"
        - "usurf"
        - "thk"
        - "slidingco"
        - "velsurf_mag"
        - "velsurfobs_mag"
        - "divflux"
        - "icemask"
    init_zero_thk: "False" # help="Initialize the optimization with zero ice thickness"
    regu_param_thk: 10.0 # help="Regularization weight for the ice thickness in the optimization"
    regu_param_slidingco: 1.0 # help="Regularization weight for the slidingco field in the optimization"
    regu_param_arrhenius: 10.0 # help="Regularization weight for the arrhenius field in the optimization"
    regu_param_div: 1.0 # help="Regularization weight for the divrgence field in the optimization"
    smooth_anisotropy_factor: 0.2 # help="Smooth anisotropy factor for the ice thickness regularization in the optimization"
    smooth_anisotropy_factor_sl: 1.0 # help="Smooth anisotropy factor for the slidingco regularization in the optimization"
    convexity_weight: 0.002 # help="Convexity weight for the ice thickness regularization in the optimization"
    convexity_power: 1.3 # help="Power b in the area-volume scaling V ~ a * A^b taking fom 'An estimate of global glacier volume', A. Grinste, TC, 2013"
    usurfobs_std: 2.0 # help="Confidence/STD of the top ice surface as input data for the optimization"
    velsurfobs_std: 1.0 # help="Confidence/STD of the surface ice velocities as input data for the optimization (if 0, velsurfobs_std field must be given)"
    thkobs_std: 3.0 # help="Confidence/STD of the ice thickness profiles (unless given)"
    divfluxobs_std: 1.0 # help="Confidence/STD of the flux divergence as input data for the optimization (if 0, divfluxobs_std field must be given)"
    divflux_method: "upwind" # help="Compute the divergence of the flux using the upwind or centered method"
    force_zero_sum_divflux: "False" # help="Add a penalty to the cost function to force the sum of the divergence of the flux to be zero"
    scaling_thk: 2.0 # help="Scaling factor for the ice thickness in the optimization, serve to adjust step-size of each controls relative to each other"
    scaling_usurf: 0.5 # help="Scaling factor for the ice thickness in the optimization, serve to adjust step-size of each controls relative to each other"
    scaling_slidingco: 0.0001 # help="Scaling factor for the slidingco in the optimization, serve to adjust step-size of each controls relative to each other"
    scaling_arrhenius: 0.1 # help="Scaling factor for the Arrhenius in the optimization, serve to adjust step-size of each controls relative to each other"
    control: ["thk"] # help="List of optimized variables for the optimization"
    cost: ["velsurf", "thk", "icemask"] # help="List of cost components for the optimization"
    nbitmin: 50 # help="Min iterations for the optimization"
    nbitmax: 500 # help="Max iterations for the optimization"
    step_size: 1.0 # help="Step size for the optimization"
    step_size_decay: 0.9 # help="Decay step size parameter for the optimization"
    output_freq: 50 # help="Frequency of the output for the optimization"
    save_result_in_ncdf: "geology-optimized.nc" # help="Geology input file"
    plot2d_live: True # help="plot2d_live_inversion"
    plot2d: True # help="plot 2d inversion"
    save_iterat_in_ncdf: True # help="write_ncdf_optimize"
    editor_plot2d: "vs" # help="optimized for VS code (vs) or spyder (sp) for live plot"
    uniformize_thkobs: True # help="uniformize the density of thkobs"
    sole_mask: False # help="sole_mask"
    retrain_iceflow_model: True # help="Retrain the iceflow model simulatounously ?"
    to_regularize: 'topg' # help="Field to regularize : topg or thk"
    include_low_speed_term: False # help="include_low_speed_term"
    infer_params: False # help="infer slidingco and convexity weight from velocity observations"
    tidewater_glacier: False # help="Is the glacier you're trying to infer parameters for a tidewater type?"
    vol_std: 1000.0 # help="Confidence/STD of the volume estimates from volume-area scaling"
    fix_opti_normalization_issue: False # help="formerly, the oce was mixing reduce_mean and l2_loss leadinf to dependence to the resolution of the grid"
    velsurfobs_thr: 0.0 # "help="Threshold for the surface ice velocities as input data for the optimization, anything below this value will be ignored"
  pretraining:
    data_dir: "surflib3d_shape_100" # help="Directory of the data of the glacier catalogu"
    batch_size: 1 # help="Batch size"
    freq_test: 20 # help="Frequence of the test"
    train_iceflow_emulator_restart_lr: 2500 # help="Restart frequency for the learning rate"
    epochs: 5000 # help="Number of epochs"
    min_arrhenius: 5.0 # help="Minium Arrhenius factor"
    max_arrhenius: 151.0 # help="Maximum Arrhenius factor"
    min_slidingco: 0.0 # help="Minimum sliding coefficient"
    max_slidingco: 20000.0 # help="Maximum sliding coefficient"
    min_coarsen: 0 # help="Minimum coarsening factor"
    max_coarsen: 2 # help="Maximum coarsening factor"
    soft_begining: 500 # help="soft_begining, if 0 explore all parameters btwe min and max, otherwise, only explore from this iteration while keeping mid-value fir the first it." 